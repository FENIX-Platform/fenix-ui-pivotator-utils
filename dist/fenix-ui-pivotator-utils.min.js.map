{"version":3,"sources":["webpack:///fenix-ui-pivotator-utils.min.js","webpack:///webpack/bootstrap b2c4fd38c62cb8f6ba40","webpack:///./src/js/index.js","webpack:///external \"underscore\""],"names":["define","__WEBPACK_EXTERNAL_MODULE_2__","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","_","parseInput","FX","opt","getDimension","ret","i","FXmod","dimensions","push","getListDim","arr","showCode","label","code","extend","convertFXDirty","inputFormat","lang","aggregationFn","value","aggregations","hidden","columns","values","groupedRow","rows","formatter","showRowHeaders","decimals","showFlag","showUnit","length","convertFX","setDimension","att","val","subject","structInter","setValue","hasOwnProperty","myColumns","key","title","split","dataType","setDirty","field","structDirty","attributes","defaultLang","Object","keys","type","unit","initFXT","FXmodnew","retObj","initFXD","initFXDgraph","toFilter","model","fxt","metadata","dsd","groupName","rowLabel","columnsLabel","hiddenLabel","aggregationsLabel","valuesLabel","configuration","dimensionsSort","selector","source","config","groups","template","hideSwitch","hideRemoveButton","aggregatorValue","maxItems","default","map","item","parent","union","toChartConfig","x","series","y","Array","isArray","typeOfChart","aggValue","Value","VALUE","show","t","ii","flag","h","attribute","toTableConfig","format","apply","undefined"],"mappings":"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","file":"fenix-ui-pivotator-utils.min.js","sourcesContent":["define([\"underscore\"], function(__WEBPACK_EXTERNAL_MODULE_2__) { return /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/\n\tif (false) {\n\t    var define = require('amdefine')(module);\n\t}\n\t\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t        __webpack_require__(2)\n\t    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (_) {\n\t\n\t        var FXmod;\n\t\n\t        function parseInput(FX, opt) {// FX.metadata.dsd,options\n\t            var ret = {};\n\t            _.extend(ret, opt);\n\t\n\t            var FXmod = convertFXDirty(FX, opt);\n\t\n\t            function getDimension() {\n\t                var ret = [];\n\t                for (var i in FXmod.dimensions) {\n\t                    ret.push(i)\n\t                }\n\t                return ret\n\t            }\n\t\n\t            function getListDim(arr, opt, FXmod) {\n\t                var showCode = opt.showCode;\n\t                var ret = [];\n\t                for (var i in arr) {\n\t                    if (showCode && FXmod.dimensions[arr[i]].label) {\n\t                        ret.push(FXmod.dimensions[arr[i]].code);\n\t                    }\n\t                    //    console.log(arr[i],FXmod.dimensions,FXmod.dimensions[arr[i]]);\n\t\n\t                    ret.push(FXmod.dimensions[arr[i]].label || FXmod.dimensions[arr[i]].code)\n\t                }\n\t                return ret\n\t            }\n\t\n\t            if (opt.inputFormat == \"fenixtool\") {\n\t\n\t                var lang = \"EN\";\n\t                if (opt.lang) {\n\t                    lang = opt.lang;\n\t                }\n\t                var aggregations = [],\n\t                    hidden = [],\n\t                    columns = [],\n\t                    rows = [],\n\t                    values = [];\n\t\n\t                ret = {\n\t                    \"inputFormat\": \"fenixTool\",\n\t                    \"aggregationFn\": opt.aggregationFn || {\"value\": \"sum\"},\n\t                    \"aggregations\": getListDim(opt.aggregations, opt, FXmod),\n\t                    \"hidden\": getListDim(opt.hidden, opt, FXmod),\n\t                    \"columns\": getListDim(opt.columns, opt, FXmod),\n\t                    \"values\": opt.values || \"value\",\n\t                    \"groupedRow\": opt.groupedRow,\n\t                    \"rows\": getListDim(opt.rows, opt, FXmod),\n\t                    \"formatter\": opt.formatter || \"value\",\n\t                    \"showRowHeaders\": opt.showRowHeaders || false,\n\t                    \"decimals\": opt.decimals || 2,\n\t                    \"showCode\": opt.showCode || false,\n\t                    \"showFlag\": opt.showFlag || false,\n\t                    \"showUnit\": opt.showUnit || false\n\t                };\n\t\n\t            }\n\t            if (ret.columns.length + ret.rows.length == 0) {\n\t                //console.log(\"FXmod\",getDimension())\n\t                ret.rows = getListDim(getDimension(), opt, FXmod)\n\t\n\t            }\n\t            return ret\n\t        }\n\t\n\t        function convertFX(FX, opt) {\n\t\n\t            //check param not null\n\t\n\t            var lang = \"EN\";\n\t            if (opt && opt.hasOwnProperty(\"lang\")) {\n\t                lang = opt.lang;\n\t            }\n\t            var structInter = {dimensions: {}, values: {}}\n\t\n\t            function setDimension(id, att, val, subject) {\n\t                if (!structInter.dimensions[id]) {\n\t                    structInter.dimensions[id] = {};\n\t                }\n\t                structInter.dimensions[id][att] = val;\n\t                if (subject) {\n\t                    structInter.dimensions[id][\"subject\"] = subject;\n\t                }\n\t            }\n\t\n\t            function setAttribute(id, att, val, subject) {\n\t                if (!structInter.attribute[id]) {\n\t                    structInter.attribute[id] = {};\n\t                }\n\t                structInter.attribute[id][att] = val;\n\t                if (subject) {\n\t                    structInter.attribute[id][\"subject\"] = subject;\n\t                }\n\t            }\n\t\n\t            function setValue(id, att, val) {\n\t                if (!structInter.values[id]) {\n\t                    structInter.values[id] = {};\n\t                }\n\t                if (att != \"attribute\") {\n\t                    structInter.values[id][att] = val;\n\t                }\n\t                else {\n\t                    if (!structInter.values[id][\"attributes\"]) {\n\t                        structInter.values[id][\"attributes\"] = [];\n\t                    }\n\t                    structInter.values[id][\"attributes\"].push(val);\n\t                }\n\t            }\n\t\n\t            for (var i in FX.columns) {\n\t                var myColumns = FX.columns[i];\n\t                if (myColumns.key == true) {//c est le code\n\t                    setDimension(myColumns.id, \"title\", myColumns.title[lang] || myColumns.id);\n\t                    setDimension(myColumns.id, \"code\", myColumns.id, myColumns.subject);\n\t                }\n\t                else if (myColumns.id.split(\"_\" + lang).length == 2) {//label\n\t                    setDimension(myColumns.id.split(\"_\" + lang)[0], \"label\", myColumns.id)\n\t                    /*\tif(!structInter.dimensions[myColumns.id.split(\"_\" + lang)[0]]){\n\t                     setDimension(myColumns.id, \"title\", myColumns.id.split(\"_\" + lang)[0]);\n\t                     setDimension(myColumns.id, \"code\",myColumns.id.split(\"_\" + lang)[0]);}*/\n\t                }\n\t                else if (myColumns.dataType == \"number\" && myColumns.subject == \"value\") {\n\t                    setValue(myColumns.id, \"value\", myColumns.id);\n\t                    setValue(myColumns.id, \"label\", myColumns.id);\n\t                    setValue(myColumns.id, \"subject\", myColumns.subject);\n\t                }\n\t                else if (myColumns.id.split(\"|*\").length == 2) {//attribut d une valeur X\n\t                    if (myColumns.subject == \"um\") {\n\t                        setValue(myColumns.id.split(\"|*\")[0], \"unit\", myColumns.id)\n\t                    }\n\t                    else if (myColumns.subject == \"flag\") {\n\t                        setValue(myColumns.id.split(\"|*\")[0], \"flag\", myColumns.id);\n\t                    }\n\t                    else {\n\t                        setValue(myColumns.id.split(\"|*\")[0], \"attributes\", myColumns.id);\n\t                    }\n\t                }\n\t                else {//attribut de value\n\t                    if (myColumns.subject == \"um\") {\n\t                        setValue(\"value\", \"unit\", myColumns.id);\n\t                    }\n\t                    else if (myColumns.subject == \"flag\") {\n\t                        setValue(\"value\", \"flag\", myColumns.id);\n\t                    }\n\t                    else {\n\t                        // setDimension(myColumns.id, \"label\", myColumns.title[lang]||myColumns.id);\n\t                        //  setDimension(myColumns.id, \"code\", myColumns.id, myColumns.subject);\n\t\n\t                        //setAttribute(myColumns.id, \"id\", myColumns.id)\n\t\n\t                        setValue(\"value\", \"attribute\", myColumns.id)\n\t                    }\n\t                }\n\t            }\n\t//\t\t\tfor()\n\t            //console.log(\"structInter\", structInter)\n\t            return structInter;\n\t        }\n\t\n\t        function convertFXDirty(FX, opt) {\n\t            //console.log(\"FXDIRTY \",FX);\n\t            var structInter = {dimensions: {}, values: {}, attributes: {}}\n\t            var structDirty = {};\n\t\n\t            var lang = \"EN\";\n\t\n\t            if (opt && opt.lang) {\n\t                lang = opt.lang;\n\t            }\n\t\n\t            function setDirty(id, field, val) {\n\t                if (!structDirty[id]) {\n\t                    structDirty[id] = {};\n\t                }\n\t                if (field == \"attributes\") {\n\t                    if (structDirty[id][field]) {\n\t                        structDirty[id][field].push(val);\n\t                    }\n\t                    else {\n\t                        structDirty[id][field] = [val];\n\t                    }\n\t\n\t                }\n\t                else {\n\t                    structDirty[id][field] = val;\n\t                }\n\t            }\n\t\n\t            for (var i in FX.columns) {\n\t                var myColumns = FX.columns[i];\n\t                var defaultLang = typeof myColumns.title === \"object\" ? Object.keys(myColumns.title)[0] : null;\n\t\n\t                if (myColumns.key == true) {//c est le code\n\t                    setDirty(myColumns.id, \"code\", myColumns.id);\n\t                    setDirty(myColumns.id, \"title\", myColumns.title[lang] || myColumns.title[defaultLang] || myColumns.id);\n\t                    setDirty(myColumns.id, \"type\", \"dimension\");\n\t                    if (myColumns.subject) {\n\t                        setDirty(myColumns.id, \"subject\", myColumns.subject);\n\t                    }\n\t\n\t                }\n\t                else if (myColumns.id.split(\"_\" + lang).length == 2) {//label\n\t                    setDirty(myColumns.id.split(\"_\" + lang)[0], \"label\", myColumns.id);\n\t\n\t                }\n\t                else if (myColumns.dataType == \"number\" && myColumns.subject == \"value\") {\n\t\n\t                    setDirty(\"value\", \"type\", \"value\");\n\t                    setDirty(\"value\", \"value\", myColumns.id);\n\t                    setDirty(\"value\", \"title\", \"value\" || myColumns.title[lang] || myColumns.title[defaultLang] || myColumns.id);\n\t\n\t                    if (myColumns.subject) {\n\t                        setDirty(\"value\", \"subject\", myColumns.subject);\n\t\n\t                    }\n\t                }\n\t                else if (myColumns.id.split(\"|*\").length == 2) {\n\t                    if (myColumns.subject == \"um\") {\n\t                        setDirty(myColumns.id.split(\"|*\")[0], \"unit\", myColumns.id);\n\t                    }\n\t                    else if (myColumns.subject == \"flag\") {\n\t                        setDirty(myColumns.id.split(\"|*\")[0], \"flag\", myColumns.id);\n\t                    }\n\t                    else {\n\t                        setDirty(myColumns.id.split(\"|*\")[0], \"attributes\", myColumns.id);\n\t                    }\n\t                }\n\t                else {\n\t\n\t                    if (myColumns.subject == \"um\") {\n\t                        //setValue(\"value\", \"unit\", myColumns.id);\n\t                        setDirty(myColumns.id, \"type\", \"attribute\");\n\t                        setDirty(myColumns.id, \"value\", myColumns.id);\n\t                        setDirty(myColumns.id, \"title\", \"unit\");\n\t                        if (myColumns.subject) {\n\t                            setDirty(myColumns.id, \"subject\", myColumns.subject);\n\t                        }\n\t                        setDirty(\"value\", \"unit\", myColumns.id)\n\t                    }\n\t                    else if (myColumns.subject == \"flag\") {\n\t                        setDirty(\"value\", \"flag\", myColumns.id)\n\t\n\t                    }\n\t                    else {\n\t                        //// setDimension(myColumns.id, \"label\", myColumns.title[lang]||myColumns.id);\n\t                        ////  setDimension(myColumns.id, \"code\", myColumns.id, myColumns.subject);\n\t                        ////setAttribute(myColumns.id, \"id\", myColumns.id)\n\t\n\t                        //setValue(\"value\", \"attribute\", myColumns.id)\n\t                        setDirty(myColumns.id, \"type\", \"attribute\");\n\t                        setDirty(myColumns.id, \"value\", myColumns.id);\n\t                        setDirty(myColumns.id, \"title\", myColumns.title[lang] || myColumns.title[defaultLang] || myColumns.id);\n\t                        if (myColumns.subject) {\n\t                            setDirty(myColumns.id, \"subject\", myColumns.subject);\n\t                        }\n\t\n\t                    }\n\t                }\n\t            }\n\t\n\t            for (var i in structDirty) {\n\t                if (structDirty[i].type == \"dimension\") {\n\t                    structInter.dimensions[i] = structDirty[i];\n\t                }\n\t                else if (structDirty[i].type == \"value\") {\n\t                    structInter.values[i] = structDirty[i];\n\t                }\n\t\n\t                else {\n\t                    structInter.attributes[i] = structDirty[i];\n\t                    if (structDirty[i].subject == \"um\") {\n\t\n\t                        if ((structInter.values.value != null) && (typeof structInter.values.value != 'undefined')) {\n\t                            structInter.values.value.unit = structDirty[i].label || structDirty[i].value;\n\t                        }\n\t                        else {\n\t\n\t                            structInter.values.value = {};\n\t                            structInter.values.value.unit = structDirty[i].label || structDirty[i].value;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t\n\t\n\t            return structInter;\n\t        }\n\t\n\t        function initFXT(FX, opt) {//for Toolbar\n\t\n\t            // var FXmodold = convertFX(FX, opt);\n\t            var FXmodnew = convertFXDirty(FX, opt);\n\t\n\t            FXmod = FXmodnew;\n\t\n\t            var hidden = [];\n\t            var columns = [];\n\t            var rows = [];\n\t            var aggregations = [];\n\t            var values = [];\n\t\n\t            for (var i in FXmod.dimensions) {\n\t                if (FXmod.dimensions[i].subject == \"time\") {\n\t                    columns.push({value: FXmod.dimensions[i].code, label: FXmod.dimensions[i].title});\n\t\n\t\n\t                }\n\t                else {\n\t                    rows.push({value: FXmod.dimensions[i].code, label: FXmod.dimensions[i].title});\n\t                }\n\t            }\n\t\n\t            for (var i in FXmod.values) {\n\t                values.push({value: FXmod.values[i].value, label: FXmod.values[i].title});\n\t            }\n\t            for (var i in FXmod.attributes) {\n\t\n\t                aggregations.push({value: FXmod.attributes[i].value, label: FXmod.attributes[i].title});\n\t            }\n\t\n\t            var retObj = {\n\t                hidden: hidden,\n\t                rows: rows,\n\t                columns: columns,\n\t                aggregations: aggregations,\n\t                values: values\n\t            }\n\t            //           console.log(retObj)\n\t            return retObj;\n\t        }\n\t\n\t        function initFXD(FX, opt) {//for Data\n\t            /*  var FXmod = convertFX(FX, opt);\n\t             var hidden = [];\n\t             var columns = [];\n\t             var rows = [];\n\t             var aggregations = [];\n\t             var values = [];\n\t             for (var i in FXmod.dimensions) {\n\t             if (opt.rows[FXmod.dimensions[i].code]) {\n\t             rows.push(FXmod.dimensions[i].label || FXmod.dimensions[i].code)\n\t             if (opt.showCode == true && FXmod.dimensions[i].title != FXmod.dimensions[i].code && FXmod.dimensions[i].title != null) {\n\t             rows.push(FXmod.dimensions[i].code)\n\t             }\n\t             }\n\t             if (opt.columns[FXmod.dimensions[i].code]) {\n\t             columns.push(FXmod.dimensions[i].label || FXmod.dimensions[i].code)\n\t             if (opt.showCode == true && FXmod.dimensions[i].title != FXmod.dimensions[i].code && FXmod.dimensions[i].title != null) {\n\t             columns.push(FXmod.dimensions[i].code)\n\t             }\n\t             }\n\t             }\n\t             for (var i in FXmod.values) {\n\t             if (opt.values[FXmod.values[i].value]) {\n\t             values.push(FXmod.values[i].value)\n\t             if (opt.showUnit == true && FXmod.values[i].unit) {\n\t             values.push(FXmod.values[i].unit);\n\t             }\n\t             if (opt.showFlag == true && FXmod.values[i].flag) {\n\t             values.push(FXmod.values[i].flag);\n\t             }\n\t             for (var h in FXmod.values[i].attribute) {\n\t             hidden.push(FXmod.values[i].attribute[h])\n\t             }\n\t\n\t             }\n\t             }\n\t             var retObj = {\n\t             hidden: hidden,\n\t             rows: rows,\n\t             columns: columns,\n\t             aggregations: aggregations,\n\t             values: values\n\t             }\n\t             return retObj;*/\n\t        }\n\t\n\t        function initFXDgraph(FX, opt) {//for Data for chart\n\t            /*  var FXmod = convertFX(FX, opt);\n\t             var hidden = [];\n\t             var x = [];\n\t             var series = [];\n\t             var aggregations = [];\n\t             var y = [];\n\t             for (var i in FXmod.dimensions) {\n\t             if (opt.series[FXmod.dimensions[i].code]) {\n\t             series.push(FXmod.dimensions[i].label || FXmod.dimensions[i].code)\n\t             if (opt.showCode == true && FXmod.dimensions[i].label != FXmod.dimensions[i].code && FXmod.dimensions[i].label != null) {\n\t             series.push(FXmod.dimensions[i].code)\n\t             }\n\t             }\n\t             if (opt.x[FXmod.dimensions[i].code]) {\n\t             x.push(FXmod.dimensions[i].label || FXmod.dimensions[i].code)\n\t             if (opt.showCode == true && FXmod.dimensions[i].label != FXmod.dimensions[i].code && FXmod.dimensions[i].label != null) {\n\t             x.push(FXmod.dimensions[i].code);\n\t             }\n\t             }\n\t             }\n\t             for (var i in FXmod.values) {\n\t             if (opt.y[FXmod.values[i].value]) {\n\t\n\t             y.push(FXmod.values[i].value)\n\t             if (opt.showUnit == true && FXmod.values[i].unit) {\n\t             y.push(FXmod.values[i].unit)\n\t             }\n\t\n\t             if (opt.showFlag == true && FXmod.values[i].flag) {\n\t             y.push(FXmod.values[i].flag)\n\t             }\n\t             for (var h in FXmod.values[i].attribute) {\n\t             hidden.push(FXmod.values[i].attribute[h])\n\t             }\n\t\n\t             }\n\t\n\t\n\t             }\n\t\n\t\n\t             var retObj = {\n\t             hidden: hidden,\n\t             series: series,\n\t             x: x,\n\t             aggregations: aggregations,\n\t             y: y\n\t             }\n\t             return retObj;*/\n\t        }\n\t\n\t        function toFilter(model, opt) {\n\t\n\t\n\t            var fxt = initFXT(model.metadata.dsd, opt);\n\t\n\t            var groupName = {\n\t                rows: \"Rows\",\n\t                columns: \"Columns\",\n\t                hidden: \"Hidden\",\n\t                aggregations: \"Aggregation\",\n\t                values: \"Values\"\n\t            };\n\t\n\t            if (opt) {\n\t                groupName = {\n\t                    rows: opt.rowLabel || \"Rows\",\n\t                    columns: opt.columnsLabel || \"Columns\",\n\t                    hidden: opt.hiddenLabel || \"Hidden\",\n\t                    aggregations: opt.aggregationsLabel || \"Aggregation\",\n\t                    values: opt.valuesLabel || \"Values\"\n\t                }\n\t            }\n\t\n\t            var configuration = {\n\t\n\t                dimensionsSort: {\n\t                    selector: {\n\t                        id: \"sortable\",\n\t                        source: [],\n\t                        config: { //SortableJS configuration\n\t                            //disabled: true\n\t                            groups: groupName\n\t                        }\n\t                    },\n\t\n\t                    template: {\n\t                        //\"hideHeader\": true,\n\t                        hideSwitch: true,\n\t                        hideRemoveButton: true,\n\t                        title: \"Sort dimension\"\n\t                    }\n\t                },\n\t                aggregatorValue: {\n\t                    selector: {\n\t                        id: 'dropdown',\n\t                        source: [\n\t                            {value: \"sum\", label: \"Sum\"},\n\t                            {value: \"avg\", label: \"avg\"},\n\t                            {value: \"median\", label: \"median\"},\n\t                            {value: \"stdev\", label: \"stdev\"},\n\t                            {value: \"count\", label: \"count\"},\n\t                            {value: \"concat\", label: \"concat\"},\n\t                            /*\n\t                             avg:function(cell,format,nbDec){var a= jStat(cell);return format(a.mean(),nbDec)},\n\t                             median:function(cell,format,nbDec){var a= jStat(cell);return format(a.median(),nbDec)},\n\t                             stdev:function(cell,format,nbDec){var a= jStat(cell);return format(a.stdev(),nbDec)},\n\t                             count:function(cell,format,nbDec){var a= cell;return format(a.length,nbDec)},\n\t                             concat\n\t\n\t                             */\n\t                        ],\n\t                        config: {maxItems: 1},\n\t                        default: ['sum']\n\t                    },\n\t\n\t                    template: {\n\t                        title: \"Aggregator for Value\"\n\t                    }\n\t                }\n\t            };\n\t\n\t            var aggregations = _.map(fxt.aggregations, function (item) {\n\t                    item.parent = \"aggregations\";\n\t                    return item\n\t                }),\n\t                columns = _.map(fxt.columns, function (item) {\n\t                    item.parent = \"columns\";\n\t                    return item\n\t                }),\n\t                rows = _.map(fxt.rows, function (item) {\n\t                    item.parent = \"rows\";\n\t                    return item\n\t                }),\n\t                hidden = _.map(fxt.hidden, function (item) {\n\t\n\t                    item.parent = \"hidden\";\n\t                    return item\n\t                }),\n\t                values = _.map(fxt.values, function (item) {\n\t                    item.parent = \"values\";\n\t                    return item\n\t                });\n\t\n\t            configuration.dimensionsSort.selector.source = _.union(aggregations, hidden, columns, rows, values);\n\t\n\t            return configuration\n\t\n\t        }\n\t\n\t        function toChartConfig(values) {\n\t            var hidden = [];\n\t            var x = [];\n\t            var series = [];\n\t            var aggregations = [];\n\t            var y = [];\n\t            var type = Array.isArray(values.values.typeOfChart) ? values.values.typeOfChart[0] : \"line\";\n\t            var aggValue = {\n\t                value: values.values.aggregatorValue[0],\n\t                Value: values.values.aggregatorValue[0],\n\t                VALUE: values.values.aggregatorValue[0]\n\t            };\n\t\n\t            //convert to chart creator configuration here\n\t            var opt = {x: {}, y: {}, series: {}, showUnit: false, showCode: false, showFlag: false};\n\t            for (var i in values.values.show) {\n\t                var t = values.values.show[i];\n\t                if (t == \"code\") {\n\t                    opt.showCode = true;\n\t                }\n\t                else if (t == \"unit\") {\n\t                    opt.showUnit = true;\n\t                }\n\t                else if (t == \"flag\") {\n\t                    opt.showFlag = true;\n\t                }\n\t            }\n\t            for (var i in values.values.dimensionsSort) {\n\t                var t = values.values.dimensionsSort[i];\n\t                if (t.parent == \"rows\") {\n\t                    opt.series[t.value] = true\n\t                }\n\t                else if (t.parent == \"columns\") {\n\t                    opt.x[t.value] = true\n\t                }\n\t                else if (t.parent == \"values\") {\n\t                    opt.y[t.value] = true\n\t                }\n\t                else if (t.parent == \"hidden\") {/* to decide what we want to do*/\n\t                }\n\t            }\n\t\n\t\n\t            // for (var i in FXmod.dimensions) {\n\t            for (var ii in values.values.dimensionsSort) {\n\t                var i = values.values.dimensionsSort[ii].value;\n\t\n\t                if (FXmod.dimensions[i] && opt.series[FXmod.dimensions[i].code]) {\n\t                    series.push(FXmod.dimensions[i].label || FXmod.dimensions[i].code)\n\t                    if (opt.showCode == true && FXmod.dimensions[i].label != FXmod.dimensions[i].code && FXmod.dimensions[i].label != null) {\n\t                        series.push(FXmod.dimensions[i].code)\n\t                    }\n\t                }\n\t                if (FXmod.dimensions[i] && opt.x[FXmod.dimensions[i].code]) {\n\t                    x.push(FXmod.dimensions[i].label || FXmod.dimensions[i].code)\n\t                    if (opt.showCode == true && FXmod.dimensions[i].label != FXmod.dimensions[i].code && FXmod.dimensions[i].label != null) {\n\t                        x.push(FXmod.dimensions[i].code);\n\t                    }\n\t                }\n\t            }\n\t            for (var i in FXmod.values) {\n\t                if (opt.y[FXmod.values[i].value]) {\n\t                    y.push(FXmod.values[i].value)\n\t                    if (opt.showUnit == true && FXmod.values[i].unit) {\n\t                        y.push(FXmod.values[i].unit)\n\t                    }\n\t                    if (opt.showFlag == true && FXmod.values[i].flag) {\n\t                        y.push(FXmod.values[i].flag)\n\t                    }\n\t                    for (var h in FXmod.values[i].attribute) {\n\t                        hidden.push(FXmod.values[i].attribute[h])\n\t                    }\n\t                }\n\t            }\n\t            for (var i in FXmod.attributes) {\n\t\n\t                if (opt.y[FXmod.attributes[i].value]) {\n\t                    y.push(FXmod.attributes[i].value);\n\t                }\n\t                else if (opt.x[FXmod.attributes[i].value]) {\n\t                    x.push(FXmod.attributes[i].value);\n\t                }\n\t                else if (opt.series[FXmod.attributes[i].value]) {\n\t                    series.push(FXmod.attributes[i].value);\n\t                }\n\t            }\n\t\n\t\n\t            var retObj = {\n\t                aggregationFn: aggValue,\n\t                formatter: \"value\",\n\t                decimals: 2,\n\t                hidden: hidden,\n\t                series: series,\n\t                x: x,\n\t                aggregations: aggregations,\n\t                y: y,\n\t                type: type\n\t            };\n\t\n\t            return retObj;\n\t\n\t\n\t        }\n\t\n\t        function toTableConfig(values) {\n\t            //console.log(\"toTableValue\",values)\n\t            var hidden = [];\n\t            var x = [];\n\t            var series = [];\n\t            var aggregations = [];\n\t            var y = [];\n\t            var formatter = values.values.format[0];\n\t            //console.log(\"values\",values)\n\t            var groupedRow = true;\n\t            if (values.values.hasOwnProperty(\"groupedRow\")) {\n\t                values.values.groupedRow.length > 0 ? groupedRow = true : groupedRow = false\n\t            }\n\t//console.log(\"values\",values)\n\t            var aggValue = {value: values.values.aggregatorValue[0], Value: values.values.aggregatorValue[0]}\n\t            //convert to chart creator configuration here\n\t            var opt = {x: {}, y: {}, series: {}, showUnit: false, showCode: false, showFlag: false};\n\t            for (var i in values.values.show) {\n\t                var t = values.values.show[i];\n\t                if (t == \"code\") {\n\t                    opt.showCode = true;\n\t                }\n\t                else if (t == \"unit\") {\n\t                    opt.showUnit = true;\n\t                }\n\t                else if (t == \"flag\") {\n\t                    opt.showFlag = true;\n\t                }\n\t            }\n\t\n\t//console.log(\" values.values.dimensionsSort\", values.values.dimensionsSort)\n\t            for (var i in values.values.dimensionsSort) {\n\t                var t = values.values.dimensionsSort[i];\n\t                if (t.parent == \"rows\") {\n\t                    opt.series[t.value] = true;\n\t                }\n\t                else if (t.parent == \"columns\") {\n\t                    opt.x[t.value] = true;\n\t                }\n\t                else if (t.parent == \"values\") {\n\t                    opt.y[t.value] = true;\n\t                }\n\t                else if (t.parent == \"hidden\") {/* to decide what we want to do*/\n\t                }\n\t            }\n\t\n\t            //console.log(\"FXmod\", FXmod)\n\t            // for (var i in FXmod.dimensions) {\n\t            for (var ii in values.values.dimensionsSort) {\n\t                var i = values.values.dimensionsSort[ii].value;\n\t                if (FXmod.dimensions[i] && opt.series[FXmod.dimensions[i].code]) {\n\t                    series.push(FXmod.dimensions[i].label || FXmod.dimensions[i].code)\n\t\n\t                    if (/*opt.showCode == true &&*/ FXmod.dimensions[i].label != FXmod.dimensions[i].code && FXmod.dimensions[i].label != null) {\n\t                        series.push(FXmod.dimensions[i].code);\n\t                        if (opt.showCode == false) {\n\t                            hidden.push(FXmod.dimensions[i].code);\n\t                        }\n\t                    }\n\t                    else {\n\t                    }\n\t                }\n\t                if (FXmod.dimensions[i] && opt.x[FXmod.dimensions[i].code]) {\n\t                    x.push(FXmod.dimensions[i].label || FXmod.dimensions[i].code)\n\t                    if (/*opt.showCode == true &&*/ FXmod.dimensions[i].label != FXmod.dimensions[i].code && FXmod.dimensions[i].label != null) {\n\t                        x.push(FXmod.dimensions[i].code);\n\t                        if (opt.showCode == false) {\n\t                            hidden.push(FXmod.dimensions[i].code);\n\t                        }\n\t                    } else {\n\t                    }\n\t                }\n\t                if (FXmod.dimensions[i] && opt.y[FXmod.dimensions[i].code]) {\n\t                    y.push(FXmod.dimensions[i].code);\n\t                } else {\n\t\n\t                }\n\t            }\n\t\n\t            for (var i in FXmod.values) {\n\t                if (opt.y[FXmod.values[i].value]) {\n\t                    y.push(FXmod.values[i].value)\n\t                    if (opt.showUnit == true && FXmod.values[i].unit) {\n\t                        y.push(FXmod.values[i].unit)\n\t                    }\n\t                    if (opt.showFlag == true && FXmod.values[i].flag) {\n\t                        y.push(FXmod.values[i].flag)\n\t                    }\n\t                    for (var h in FXmod.values[i].attribute) {\n\t                        hidden.push(FXmod.values[i].attribute[h])\n\t                    }\n\t                }\n\t            }\n\t\n\t            for (var i in FXmod.attributes) {\n\t\n\t                if (opt.y[FXmod.attributes[i].value]) {\n\t                    y.push(FXmod.attributes[i].label || FXmod.attributes[i].value);\n\t                }\n\t                else if (opt.x[FXmod.attributes[i].value]) {\n\t                    x.push(FXmod.attributes[i].label || FXmod.attributes[i].value);\n\t                }\n\t                else if (opt.series[FXmod.attributes[i].value]) {\n\t                    series.push(FXmod.attributes[i].label || FXmod.attributes[i].value);\n\t                }\n\t            }\n\t\n\t//console.log(\"V\",values.values)\n\t            var retObj = {\n\t                groupedRow: groupedRow,\n\t                aggregationFn: aggValue,\n\t                formatter: formatter,\n\t                decimals: values.values.decimals || 2,\n\t                showRowHeaders: true,\n\t                hidden: hidden,\n\t                rows: series,\n\t                columns: x,\n\t                aggregations: aggregations,\n\t                values: y\n\t            }\n\t            //console.log(\"rest\",retObj)\n\t            return retObj;\n\t\n\t\n\t        }\n\t\n\t        return function () {\n\t            return {\n\t                convertFX: convertFX,\n\t                initFXT: initFXT,\n\t                initFXD: initFXD,\n\t                initFXDgraph: initFXDgraph,\n\t                parseInput: parseInput,\n\t                toFilter: toFilter,\n\t                toChartConfig: toChartConfig,\n\t                toTableConfig: toTableConfig\n\t            }\n\t        };\n\t    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ }\n/******/ ])});;\n\n\n/** WEBPACK FOOTER **\n ** fenix-ui-pivotator-utils.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap b2c4fd38c62cb8f6ba40\n **/","/*global define*/\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module);\n}\n\ndefine([\n        \"underscore\"\n    ], function (_) {\n\n        var FXmod;\n\n        function parseInput(FX, opt) {// FX.metadata.dsd,options\n            var ret = {};\n            _.extend(ret, opt);\n\n            var FXmod = convertFXDirty(FX, opt);\n\n            function getDimension() {\n                var ret = [];\n                for (var i in FXmod.dimensions) {\n                    ret.push(i)\n                }\n                return ret\n            }\n\n            function getListDim(arr, opt, FXmod) {\n                var showCode = opt.showCode;\n                var ret = [];\n                for (var i in arr) {\n                    if (showCode && FXmod.dimensions[arr[i]].label) {\n                        ret.push(FXmod.dimensions[arr[i]].code);\n                    }\n                    //    console.log(arr[i],FXmod.dimensions,FXmod.dimensions[arr[i]]);\n\n                    ret.push(FXmod.dimensions[arr[i]].label || FXmod.dimensions[arr[i]].code)\n                }\n                return ret\n            }\n\n            if (opt.inputFormat == \"fenixtool\") {\n\n                var lang = \"EN\";\n                if (opt.lang) {\n                    lang = opt.lang;\n                }\n                var aggregations = [],\n                    hidden = [],\n                    columns = [],\n                    rows = [],\n                    values = [];\n\n                ret = {\n                    \"inputFormat\": \"fenixTool\",\n                    \"aggregationFn\": opt.aggregationFn || {\"value\": \"sum\"},\n                    \"aggregations\": getListDim(opt.aggregations, opt, FXmod),\n                    \"hidden\": getListDim(opt.hidden, opt, FXmod),\n                    \"columns\": getListDim(opt.columns, opt, FXmod),\n                    \"values\": opt.values || \"value\",\n                    \"groupedRow\": opt.groupedRow,\n                    \"rows\": getListDim(opt.rows, opt, FXmod),\n                    \"formatter\": opt.formatter || \"value\",\n                    \"showRowHeaders\": opt.showRowHeaders || false,\n                    \"decimals\": opt.decimals || 2,\n                    \"showCode\": opt.showCode || false,\n                    \"showFlag\": opt.showFlag || false,\n                    \"showUnit\": opt.showUnit || false\n                };\n\n            }\n            if (ret.columns.length + ret.rows.length == 0) {\n                //console.log(\"FXmod\",getDimension())\n                ret.rows = getListDim(getDimension(), opt, FXmod)\n\n            }\n            return ret\n        }\n\n        function convertFX(FX, opt) {\n\n            //check param not null\n\n            var lang = \"EN\";\n            if (opt && opt.hasOwnProperty(\"lang\")) {\n                lang = opt.lang;\n            }\n            var structInter = {dimensions: {}, values: {}}\n\n            function setDimension(id, att, val, subject) {\n                if (!structInter.dimensions[id]) {\n                    structInter.dimensions[id] = {};\n                }\n                structInter.dimensions[id][att] = val;\n                if (subject) {\n                    structInter.dimensions[id][\"subject\"] = subject;\n                }\n            }\n\n            function setAttribute(id, att, val, subject) {\n                if (!structInter.attribute[id]) {\n                    structInter.attribute[id] = {};\n                }\n                structInter.attribute[id][att] = val;\n                if (subject) {\n                    structInter.attribute[id][\"subject\"] = subject;\n                }\n            }\n\n            function setValue(id, att, val) {\n                if (!structInter.values[id]) {\n                    structInter.values[id] = {};\n                }\n                if (att != \"attribute\") {\n                    structInter.values[id][att] = val;\n                }\n                else {\n                    if (!structInter.values[id][\"attributes\"]) {\n                        structInter.values[id][\"attributes\"] = [];\n                    }\n                    structInter.values[id][\"attributes\"].push(val);\n                }\n            }\n\n            for (var i in FX.columns) {\n                var myColumns = FX.columns[i];\n                if (myColumns.key == true) {//c est le code\n                    setDimension(myColumns.id, \"title\", myColumns.title[lang] || myColumns.id);\n                    setDimension(myColumns.id, \"code\", myColumns.id, myColumns.subject);\n                }\n                else if (myColumns.id.split(\"_\" + lang).length == 2) {//label\n                    setDimension(myColumns.id.split(\"_\" + lang)[0], \"label\", myColumns.id)\n                    /*\tif(!structInter.dimensions[myColumns.id.split(\"_\" + lang)[0]]){\n                     setDimension(myColumns.id, \"title\", myColumns.id.split(\"_\" + lang)[0]);\n                     setDimension(myColumns.id, \"code\",myColumns.id.split(\"_\" + lang)[0]);}*/\n                }\n                else if (myColumns.dataType == \"number\" && myColumns.subject == \"value\") {\n                    setValue(myColumns.id, \"value\", myColumns.id);\n                    setValue(myColumns.id, \"label\", myColumns.id);\n                    setValue(myColumns.id, \"subject\", myColumns.subject);\n                }\n                else if (myColumns.id.split(\"|*\").length == 2) {//attribut d une valeur X\n                    if (myColumns.subject == \"um\") {\n                        setValue(myColumns.id.split(\"|*\")[0], \"unit\", myColumns.id)\n                    }\n                    else if (myColumns.subject == \"flag\") {\n                        setValue(myColumns.id.split(\"|*\")[0], \"flag\", myColumns.id);\n                    }\n                    else {\n                        setValue(myColumns.id.split(\"|*\")[0], \"attributes\", myColumns.id);\n                    }\n                }\n                else {//attribut de value\n                    if (myColumns.subject == \"um\") {\n                        setValue(\"value\", \"unit\", myColumns.id);\n                    }\n                    else if (myColumns.subject == \"flag\") {\n                        setValue(\"value\", \"flag\", myColumns.id);\n                    }\n                    else {\n                        // setDimension(myColumns.id, \"label\", myColumns.title[lang]||myColumns.id);\n                        //  setDimension(myColumns.id, \"code\", myColumns.id, myColumns.subject);\n\n                        //setAttribute(myColumns.id, \"id\", myColumns.id)\n\n                        setValue(\"value\", \"attribute\", myColumns.id)\n                    }\n                }\n            }\n//\t\t\tfor()\n            //console.log(\"structInter\", structInter)\n            return structInter;\n        }\n\n        function convertFXDirty(FX, opt) {\n            //console.log(\"FXDIRTY \",FX);\n            var structInter = {dimensions: {}, values: {}, attributes: {}}\n            var structDirty = {};\n\n            var lang = \"EN\";\n\n            if (opt && opt.lang) {\n                lang = opt.lang;\n            }\n\n            function setDirty(id, field, val) {\n                if (!structDirty[id]) {\n                    structDirty[id] = {};\n                }\n                if (field == \"attributes\") {\n                    if (structDirty[id][field]) {\n                        structDirty[id][field].push(val);\n                    }\n                    else {\n                        structDirty[id][field] = [val];\n                    }\n\n                }\n                else {\n                    structDirty[id][field] = val;\n                }\n            }\n\n            for (var i in FX.columns) {\n                var myColumns = FX.columns[i];\n                var defaultLang = typeof myColumns.title === \"object\" ? Object.keys(myColumns.title)[0] : null;\n\n                if (myColumns.key == true) {//c est le code\n                    setDirty(myColumns.id, \"code\", myColumns.id);\n                    setDirty(myColumns.id, \"title\", myColumns.title[lang] || myColumns.title[defaultLang] || myColumns.id);\n                    setDirty(myColumns.id, \"type\", \"dimension\");\n                    if (myColumns.subject) {\n                        setDirty(myColumns.id, \"subject\", myColumns.subject);\n                    }\n\n                }\n                else if (myColumns.id.split(\"_\" + lang).length == 2) {//label\n                    setDirty(myColumns.id.split(\"_\" + lang)[0], \"label\", myColumns.id);\n\n                }\n                else if (myColumns.dataType == \"number\" && myColumns.subject == \"value\") {\n\n                    setDirty(\"value\", \"type\", \"value\");\n                    setDirty(\"value\", \"value\", myColumns.id);\n                    setDirty(\"value\", \"title\", \"value\" || myColumns.title[lang] || myColumns.title[defaultLang] || myColumns.id);\n\n                    if (myColumns.subject) {\n                        setDirty(\"value\", \"subject\", myColumns.subject);\n\n                    }\n                }\n                else if (myColumns.id.split(\"|*\").length == 2) {\n                    if (myColumns.subject == \"um\") {\n                        setDirty(myColumns.id.split(\"|*\")[0], \"unit\", myColumns.id);\n                    }\n                    else if (myColumns.subject == \"flag\") {\n                        setDirty(myColumns.id.split(\"|*\")[0], \"flag\", myColumns.id);\n                    }\n                    else {\n                        setDirty(myColumns.id.split(\"|*\")[0], \"attributes\", myColumns.id);\n                    }\n                }\n                else {\n\n                    if (myColumns.subject == \"um\") {\n                        //setValue(\"value\", \"unit\", myColumns.id);\n                        setDirty(myColumns.id, \"type\", \"attribute\");\n                        setDirty(myColumns.id, \"value\", myColumns.id);\n                        setDirty(myColumns.id, \"title\", \"unit\");\n                        if (myColumns.subject) {\n                            setDirty(myColumns.id, \"subject\", myColumns.subject);\n                        }\n                        setDirty(\"value\", \"unit\", myColumns.id)\n                    }\n                    else if (myColumns.subject == \"flag\") {\n                        setDirty(\"value\", \"flag\", myColumns.id)\n\n                    }\n                    else {\n                        //// setDimension(myColumns.id, \"label\", myColumns.title[lang]||myColumns.id);\n                        ////  setDimension(myColumns.id, \"code\", myColumns.id, myColumns.subject);\n                        ////setAttribute(myColumns.id, \"id\", myColumns.id)\n\n                        //setValue(\"value\", \"attribute\", myColumns.id)\n                        setDirty(myColumns.id, \"type\", \"attribute\");\n                        setDirty(myColumns.id, \"value\", myColumns.id);\n                        setDirty(myColumns.id, \"title\", myColumns.title[lang] || myColumns.title[defaultLang] || myColumns.id);\n                        if (myColumns.subject) {\n                            setDirty(myColumns.id, \"subject\", myColumns.subject);\n                        }\n\n                    }\n                }\n            }\n\n            for (var i in structDirty) {\n                if (structDirty[i].type == \"dimension\") {\n                    structInter.dimensions[i] = structDirty[i];\n                }\n                else if (structDirty[i].type == \"value\") {\n                    structInter.values[i] = structDirty[i];\n                }\n\n                else {\n                    structInter.attributes[i] = structDirty[i];\n                    if (structDirty[i].subject == \"um\") {\n\n                        if ((structInter.values.value != null) && (typeof structInter.values.value != 'undefined')) {\n                            structInter.values.value.unit = structDirty[i].label || structDirty[i].value;\n                        }\n                        else {\n\n                            structInter.values.value = {};\n                            structInter.values.value.unit = structDirty[i].label || structDirty[i].value;\n                        }\n                    }\n                }\n            }\n\n\n            return structInter;\n        }\n\n        function initFXT(FX, opt) {//for Toolbar\n\n            // var FXmodold = convertFX(FX, opt);\n            var FXmodnew = convertFXDirty(FX, opt);\n\n            FXmod = FXmodnew;\n\n            var hidden = [];\n            var columns = [];\n            var rows = [];\n            var aggregations = [];\n            var values = [];\n\n            for (var i in FXmod.dimensions) {\n                if (FXmod.dimensions[i].subject == \"time\") {\n                    columns.push({value: FXmod.dimensions[i].code, label: FXmod.dimensions[i].title});\n\n\n                }\n                else {\n                    rows.push({value: FXmod.dimensions[i].code, label: FXmod.dimensions[i].title});\n                }\n            }\n\n            for (var i in FXmod.values) {\n                values.push({value: FXmod.values[i].value, label: FXmod.values[i].title});\n            }\n            for (var i in FXmod.attributes) {\n\n                aggregations.push({value: FXmod.attributes[i].value, label: FXmod.attributes[i].title});\n            }\n\n            var retObj = {\n                hidden: hidden,\n                rows: rows,\n                columns: columns,\n                aggregations: aggregations,\n                values: values\n            }\n            //           console.log(retObj)\n            return retObj;\n        }\n\n        function initFXD(FX, opt) {//for Data\n            /*  var FXmod = convertFX(FX, opt);\n             var hidden = [];\n             var columns = [];\n             var rows = [];\n             var aggregations = [];\n             var values = [];\n             for (var i in FXmod.dimensions) {\n             if (opt.rows[FXmod.dimensions[i].code]) {\n             rows.push(FXmod.dimensions[i].label || FXmod.dimensions[i].code)\n             if (opt.showCode == true && FXmod.dimensions[i].title != FXmod.dimensions[i].code && FXmod.dimensions[i].title != null) {\n             rows.push(FXmod.dimensions[i].code)\n             }\n             }\n             if (opt.columns[FXmod.dimensions[i].code]) {\n             columns.push(FXmod.dimensions[i].label || FXmod.dimensions[i].code)\n             if (opt.showCode == true && FXmod.dimensions[i].title != FXmod.dimensions[i].code && FXmod.dimensions[i].title != null) {\n             columns.push(FXmod.dimensions[i].code)\n             }\n             }\n             }\n             for (var i in FXmod.values) {\n             if (opt.values[FXmod.values[i].value]) {\n             values.push(FXmod.values[i].value)\n             if (opt.showUnit == true && FXmod.values[i].unit) {\n             values.push(FXmod.values[i].unit);\n             }\n             if (opt.showFlag == true && FXmod.values[i].flag) {\n             values.push(FXmod.values[i].flag);\n             }\n             for (var h in FXmod.values[i].attribute) {\n             hidden.push(FXmod.values[i].attribute[h])\n             }\n\n             }\n             }\n             var retObj = {\n             hidden: hidden,\n             rows: rows,\n             columns: columns,\n             aggregations: aggregations,\n             values: values\n             }\n             return retObj;*/\n        }\n\n        function initFXDgraph(FX, opt) {//for Data for chart\n            /*  var FXmod = convertFX(FX, opt);\n             var hidden = [];\n             var x = [];\n             var series = [];\n             var aggregations = [];\n             var y = [];\n             for (var i in FXmod.dimensions) {\n             if (opt.series[FXmod.dimensions[i].code]) {\n             series.push(FXmod.dimensions[i].label || FXmod.dimensions[i].code)\n             if (opt.showCode == true && FXmod.dimensions[i].label != FXmod.dimensions[i].code && FXmod.dimensions[i].label != null) {\n             series.push(FXmod.dimensions[i].code)\n             }\n             }\n             if (opt.x[FXmod.dimensions[i].code]) {\n             x.push(FXmod.dimensions[i].label || FXmod.dimensions[i].code)\n             if (opt.showCode == true && FXmod.dimensions[i].label != FXmod.dimensions[i].code && FXmod.dimensions[i].label != null) {\n             x.push(FXmod.dimensions[i].code);\n             }\n             }\n             }\n             for (var i in FXmod.values) {\n             if (opt.y[FXmod.values[i].value]) {\n\n             y.push(FXmod.values[i].value)\n             if (opt.showUnit == true && FXmod.values[i].unit) {\n             y.push(FXmod.values[i].unit)\n             }\n\n             if (opt.showFlag == true && FXmod.values[i].flag) {\n             y.push(FXmod.values[i].flag)\n             }\n             for (var h in FXmod.values[i].attribute) {\n             hidden.push(FXmod.values[i].attribute[h])\n             }\n\n             }\n\n\n             }\n\n\n             var retObj = {\n             hidden: hidden,\n             series: series,\n             x: x,\n             aggregations: aggregations,\n             y: y\n             }\n             return retObj;*/\n        }\n\n        function toFilter(model, opt) {\n\n\n            var fxt = initFXT(model.metadata.dsd, opt);\n\n            var groupName = {\n                rows: \"Rows\",\n                columns: \"Columns\",\n                hidden: \"Hidden\",\n                aggregations: \"Aggregation\",\n                values: \"Values\"\n            };\n\n            if (opt) {\n                groupName = {\n                    rows: opt.rowLabel || \"Rows\",\n                    columns: opt.columnsLabel || \"Columns\",\n                    hidden: opt.hiddenLabel || \"Hidden\",\n                    aggregations: opt.aggregationsLabel || \"Aggregation\",\n                    values: opt.valuesLabel || \"Values\"\n                }\n            }\n\n            var configuration = {\n\n                dimensionsSort: {\n                    selector: {\n                        id: \"sortable\",\n                        source: [],\n                        config: { //SortableJS configuration\n                            //disabled: true\n                            groups: groupName\n                        }\n                    },\n\n                    template: {\n                        //\"hideHeader\": true,\n                        hideSwitch: true,\n                        hideRemoveButton: true,\n                        title: \"Sort dimension\"\n                    }\n                },\n                aggregatorValue: {\n                    selector: {\n                        id: 'dropdown',\n                        source: [\n                            {value: \"sum\", label: \"Sum\"},\n                            {value: \"avg\", label: \"avg\"},\n                            {value: \"median\", label: \"median\"},\n                            {value: \"stdev\", label: \"stdev\"},\n                            {value: \"count\", label: \"count\"},\n                            {value: \"concat\", label: \"concat\"},\n                            /*\n                             avg:function(cell,format,nbDec){var a= jStat(cell);return format(a.mean(),nbDec)},\n                             median:function(cell,format,nbDec){var a= jStat(cell);return format(a.median(),nbDec)},\n                             stdev:function(cell,format,nbDec){var a= jStat(cell);return format(a.stdev(),nbDec)},\n                             count:function(cell,format,nbDec){var a= cell;return format(a.length,nbDec)},\n                             concat\n\n                             */\n                        ],\n                        config: {maxItems: 1},\n                        default: ['sum']\n                    },\n\n                    template: {\n                        title: \"Aggregator for Value\"\n                    }\n                }\n            };\n\n            var aggregations = _.map(fxt.aggregations, function (item) {\n                    item.parent = \"aggregations\";\n                    return item\n                }),\n                columns = _.map(fxt.columns, function (item) {\n                    item.parent = \"columns\";\n                    return item\n                }),\n                rows = _.map(fxt.rows, function (item) {\n                    item.parent = \"rows\";\n                    return item\n                }),\n                hidden = _.map(fxt.hidden, function (item) {\n\n                    item.parent = \"hidden\";\n                    return item\n                }),\n                values = _.map(fxt.values, function (item) {\n                    item.parent = \"values\";\n                    return item\n                });\n\n            configuration.dimensionsSort.selector.source = _.union(aggregations, hidden, columns, rows, values);\n\n            return configuration\n\n        }\n\n        function toChartConfig(values) {\n            var hidden = [];\n            var x = [];\n            var series = [];\n            var aggregations = [];\n            var y = [];\n            var type = Array.isArray(values.values.typeOfChart) ? values.values.typeOfChart[0] : \"line\";\n            var aggValue = {\n                value: values.values.aggregatorValue[0],\n                Value: values.values.aggregatorValue[0],\n                VALUE: values.values.aggregatorValue[0]\n            };\n\n            //convert to chart creator configuration here\n            var opt = {x: {}, y: {}, series: {}, showUnit: false, showCode: false, showFlag: false};\n            for (var i in values.values.show) {\n                var t = values.values.show[i];\n                if (t == \"code\") {\n                    opt.showCode = true;\n                }\n                else if (t == \"unit\") {\n                    opt.showUnit = true;\n                }\n                else if (t == \"flag\") {\n                    opt.showFlag = true;\n                }\n            }\n            for (var i in values.values.dimensionsSort) {\n                var t = values.values.dimensionsSort[i];\n                if (t.parent == \"rows\") {\n                    opt.series[t.value] = true\n                }\n                else if (t.parent == \"columns\") {\n                    opt.x[t.value] = true\n                }\n                else if (t.parent == \"values\") {\n                    opt.y[t.value] = true\n                }\n                else if (t.parent == \"hidden\") {/* to decide what we want to do*/\n                }\n            }\n\n\n            // for (var i in FXmod.dimensions) {\n            for (var ii in values.values.dimensionsSort) {\n                var i = values.values.dimensionsSort[ii].value;\n\n                if (FXmod.dimensions[i] && opt.series[FXmod.dimensions[i].code]) {\n                    series.push(FXmod.dimensions[i].label || FXmod.dimensions[i].code)\n                    if (opt.showCode == true && FXmod.dimensions[i].label != FXmod.dimensions[i].code && FXmod.dimensions[i].label != null) {\n                        series.push(FXmod.dimensions[i].code)\n                    }\n                }\n                if (FXmod.dimensions[i] && opt.x[FXmod.dimensions[i].code]) {\n                    x.push(FXmod.dimensions[i].label || FXmod.dimensions[i].code)\n                    if (opt.showCode == true && FXmod.dimensions[i].label != FXmod.dimensions[i].code && FXmod.dimensions[i].label != null) {\n                        x.push(FXmod.dimensions[i].code);\n                    }\n                }\n            }\n            for (var i in FXmod.values) {\n                if (opt.y[FXmod.values[i].value]) {\n                    y.push(FXmod.values[i].value)\n                    if (opt.showUnit == true && FXmod.values[i].unit) {\n                        y.push(FXmod.values[i].unit)\n                    }\n                    if (opt.showFlag == true && FXmod.values[i].flag) {\n                        y.push(FXmod.values[i].flag)\n                    }\n                    for (var h in FXmod.values[i].attribute) {\n                        hidden.push(FXmod.values[i].attribute[h])\n                    }\n                }\n            }\n            for (var i in FXmod.attributes) {\n\n                if (opt.y[FXmod.attributes[i].value]) {\n                    y.push(FXmod.attributes[i].value);\n                }\n                else if (opt.x[FXmod.attributes[i].value]) {\n                    x.push(FXmod.attributes[i].value);\n                }\n                else if (opt.series[FXmod.attributes[i].value]) {\n                    series.push(FXmod.attributes[i].value);\n                }\n            }\n\n\n            var retObj = {\n                aggregationFn: aggValue,\n                formatter: \"value\",\n                decimals: 2,\n                hidden: hidden,\n                series: series,\n                x: x,\n                aggregations: aggregations,\n                y: y,\n                type: type\n            };\n\n            return retObj;\n\n\n        }\n\n        function toTableConfig(values) {\n            //console.log(\"toTableValue\",values)\n            var hidden = [];\n            var x = [];\n            var series = [];\n            var aggregations = [];\n            var y = [];\n            var formatter = values.values.format[0];\n            //console.log(\"values\",values)\n            var groupedRow = true;\n            if (values.values.hasOwnProperty(\"groupedRow\")) {\n                values.values.groupedRow.length > 0 ? groupedRow = true : groupedRow = false\n            }\n//console.log(\"values\",values)\n            var aggValue = {value: values.values.aggregatorValue[0], Value: values.values.aggregatorValue[0]}\n            //convert to chart creator configuration here\n            var opt = {x: {}, y: {}, series: {}, showUnit: false, showCode: false, showFlag: false};\n            for (var i in values.values.show) {\n                var t = values.values.show[i];\n                if (t == \"code\") {\n                    opt.showCode = true;\n                }\n                else if (t == \"unit\") {\n                    opt.showUnit = true;\n                }\n                else if (t == \"flag\") {\n                    opt.showFlag = true;\n                }\n            }\n\n//console.log(\" values.values.dimensionsSort\", values.values.dimensionsSort)\n            for (var i in values.values.dimensionsSort) {\n                var t = values.values.dimensionsSort[i];\n                if (t.parent == \"rows\") {\n                    opt.series[t.value] = true;\n                }\n                else if (t.parent == \"columns\") {\n                    opt.x[t.value] = true;\n                }\n                else if (t.parent == \"values\") {\n                    opt.y[t.value] = true;\n                }\n                else if (t.parent == \"hidden\") {/* to decide what we want to do*/\n                }\n            }\n\n            //console.log(\"FXmod\", FXmod)\n            // for (var i in FXmod.dimensions) {\n            for (var ii in values.values.dimensionsSort) {\n                var i = values.values.dimensionsSort[ii].value;\n                if (FXmod.dimensions[i] && opt.series[FXmod.dimensions[i].code]) {\n                    series.push(FXmod.dimensions[i].label || FXmod.dimensions[i].code)\n\n                    if (/*opt.showCode == true &&*/ FXmod.dimensions[i].label != FXmod.dimensions[i].code && FXmod.dimensions[i].label != null) {\n                        series.push(FXmod.dimensions[i].code);\n                        if (opt.showCode == false) {\n                            hidden.push(FXmod.dimensions[i].code);\n                        }\n                    }\n                    else {\n                    }\n                }\n                if (FXmod.dimensions[i] && opt.x[FXmod.dimensions[i].code]) {\n                    x.push(FXmod.dimensions[i].label || FXmod.dimensions[i].code)\n                    if (/*opt.showCode == true &&*/ FXmod.dimensions[i].label != FXmod.dimensions[i].code && FXmod.dimensions[i].label != null) {\n                        x.push(FXmod.dimensions[i].code);\n                        if (opt.showCode == false) {\n                            hidden.push(FXmod.dimensions[i].code);\n                        }\n                    } else {\n                    }\n                }\n                if (FXmod.dimensions[i] && opt.y[FXmod.dimensions[i].code]) {\n                    y.push(FXmod.dimensions[i].code);\n                } else {\n\n                }\n            }\n\n            for (var i in FXmod.values) {\n                if (opt.y[FXmod.values[i].value]) {\n                    y.push(FXmod.values[i].value)\n                    if (opt.showUnit == true && FXmod.values[i].unit) {\n                        y.push(FXmod.values[i].unit)\n                    }\n                    if (opt.showFlag == true && FXmod.values[i].flag) {\n                        y.push(FXmod.values[i].flag)\n                    }\n                    for (var h in FXmod.values[i].attribute) {\n                        hidden.push(FXmod.values[i].attribute[h])\n                    }\n                }\n            }\n\n            for (var i in FXmod.attributes) {\n\n                if (opt.y[FXmod.attributes[i].value]) {\n                    y.push(FXmod.attributes[i].label || FXmod.attributes[i].value);\n                }\n                else if (opt.x[FXmod.attributes[i].value]) {\n                    x.push(FXmod.attributes[i].label || FXmod.attributes[i].value);\n                }\n                else if (opt.series[FXmod.attributes[i].value]) {\n                    series.push(FXmod.attributes[i].label || FXmod.attributes[i].value);\n                }\n            }\n\n//console.log(\"V\",values.values)\n            var retObj = {\n                groupedRow: groupedRow,\n                aggregationFn: aggValue,\n                formatter: formatter,\n                decimals: values.values.decimals || 2,\n                showRowHeaders: true,\n                hidden: hidden,\n                rows: series,\n                columns: x,\n                aggregations: aggregations,\n                values: y\n            }\n            //console.log(\"rest\",retObj)\n            return retObj;\n\n\n        }\n\n        return function () {\n            return {\n                convertFX: convertFX,\n                initFXT: initFXT,\n                initFXD: initFXD,\n                initFXDgraph: initFXDgraph,\n                parseInput: parseInput,\n                toFilter: toFilter,\n                toChartConfig: toChartConfig,\n                toTableConfig: toTableConfig\n            }\n        };\n    }\n);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/index.js\n ** module id = 1\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"underscore\"\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}